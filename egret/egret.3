'\" t
.\" Manual page created with latex2man.pl on Mon Dec  9 00:59:36 CET 2002
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "Egret" "3" "2002/08/01" "Pleinpot documentation " "Pleinpot documentation "
.SH NAME

egret 
.PP
.SH PURPOSE
EGRET - Extra Galactic Database Request Entry Table.
.SH AUTHOR
.AU
Maneesh Sahani
Xiuqin Wu
.AI
NED Group
 Infrared Processing and Analysis Centre,
 California Institute of Technology,
 Pasadena, California 91125.
.AB
.br
This document decribes the creation of a program to screen keyboard
entry and accept, modify, or reject it as required, using Egret. This
system was designed to screen input to the NED database, at IPAC over
the Summer of 1989.
.AE
.SH SYNOPSIS
.DS L
egretc [-cCiIlLnNsS] [-o outfile] infile
[ lex muscles
  cc lex.yy.c egret.rect.c egret.util.o -ll -o egret ]
egret                                             
.DE
.SH INTRODUCTION
.LP
Egret was originally intended to be a database preprocessor, capable
of reading input and matching it against a pre-set list of permissible
input, editing the input to put it into a standard form and outputting
that standard form. It can handle arbitrary character strings, and
numbers that must fall in a certain range. The specification of
permissible forms is made in a configuration file which by default is
called "micro_db". For historical reasons this document will often
refer to this file as the micro database, which is where the default
name originates from.
.LP
The principle component of the Egret system is the program egretc
which converts the configuration file to a c program using flex(1), a
lexical analyser developed at the University of California, Berkeley,
and soon to be included in the standard BSD software. This is compiled
along with a file of rectification procedures and the library file
egret.util.o to produce an executable called, by default, egret.
.SH THE MICRO DATABASE
.LP
The program generated by egretc is desribed in a file which is
specified on the command line so:
.DS
egretc infilename
.DE
Each non-blank line in this file should begin with one of the
follonwing characters: n,0,1,2,<,# or %. Lines that consist of nothing
but a newline character and those that start with a % or # symbol are
ignored by the compiler. Any line that does not begin with one of the
characters listed above will cause an error message to be printed and
the line will be ignored. Legal lines fall into the following
categories:
.IP Comments: 12
Lines that begin with the characters %, # or \\n (empty lines) are
ignored by the compiler. Two distinct symbols were provided for
comments as it was important in the original application to allow some
comments to be readable by other programs, while some were just to
increase human readability. In keeping with this it is suggested that
the symbol % be used for explanatory data on entries in the file, and
# for explicative comments, dates of modification etc.
.IP Notes
Lines that begin with the symbol n are specifications of note strings
that egret accepts at the end of any input, except that where it is
specifically required not to. The basic form of a notes line is the
same as a command line. See the section below titled "notes" for more
information.
.IP Commands
The symbols 0, 1 and 2 at the beginning of a line indicate that the
line is a command that egretc should read. These lines describe
regular expressions that egret will scan its input in search of, and
also describe the actions that must be taken to put recognized input
into a standard form. Command lines have three parts: the type
specifier, which is just the first character, the line instructions,
which are everything upto the first > symbol in the line and set
various conditions under which the line should be compiled, and the
expression which is whatever follows that first >. As may have been
gathered it is essential that a command line contain a > symbol, and
this symbol is special. The various parts of the command are discussed
in more detail below.
.IP Errors
It is also possible to insert error messages that should be printed on
screen under certain conditions. These are prefixed by the symbol <.
Error messages too, are discussed below.
.SH Commands
This section describes in detail the form and functionality of command
lines in the configuration file.
.LP
.NH 3
Type Specifier
.LP
The first character on the line indicates the priority of the match.
Lines beginning with a 0 are tested first and should be kept as simple
as possible. 1 type  expressions are intended to be less common than 0
ones but still be accepted without question. Entries that begin with a
2 are at least potentially ambiguous and the user will be asked at the
very least to confirm the entry.
.QP 
IMPORTANT: If a 0 or 1 level expression is matched by egret it will
look no further in the table. Therefore any request form that may
even possibly be ambiguous should be placed at the 2 level.
.LP
.NH 3
Line Instructions
.LP
The space between the initial digit and the '>' symbol is used to give
egretc information relevant only to this line. The following symbols
are recognized (note the similarity to the compilation options ):
.IP
.RS
.IP *:
compile this line in the opposite case sensitivity to global
compilation option. This is basically a historical remnant with little
usefulness. The options c and C are more useful.
.IP c:
compile this line in case insensitive mode. Overrides
compilation option
.IP C:
compile this line in case sensitive mode. Overrides
compilation option.
.IP n:
accept a notes string at the end of an entry of this form. See "notes"
below for a discussion of the notes facility. An entry of this form
overrides the global compiler option set by default or on the command line.
.IP N:
do not accept notes at the end of this string. If a string that
matches the notes specified is entered by the user after this entry it
will be read, but not included in the output from the program. A
warning message informing the user that this was done will be printed.
.IP s:
collapse the spaces in this line. This instructs egret to match any
number of spaces as opposed to just one, anywhere that a space appears
in parentheses. In addition egret preprocesses the input to replace
any number of successive spaces by a single one. This option overrides
the compiler option
.IP S:
do not collapse spaces. Every space on the line is literally one
space. Overrides compiler option.
.IP quotes:
text between quotes in this section of the line is text
which is to be printed whenever this expression is matched.
.RE
.LP
.NH 3
Expressions
.LP
Any text on a line after a > symbol must serve two purposes.
The first is to instruct the output to look for certain patterns in
its input. The second is to tell it how to put that input into a
standard form. We will first discuss matching text, and then numbers.
One may use the text matching to look for digits in the input, but
egret will just treat them as characters like any other character. If
number matching is used, on the other hand, egret is concious of the
value of the input number and can do things like range checking.
.LP
.NH 4
Text Commands
.LP
Text is specified in one of two ways. Either as text that needs to be
matched or as text that must be inserted. Matching text may be of
either of two forms:
Text placed between parentheses ( , ) is
matched exactly in its entirety. Thus (ABC) will match only the string
"ABC". Text between braces [ , ] is matched if any one of its
characters is matched. Thus [ABC] matches only the strings "A", "B" or
"C" and no others. Ranges are permitted so that the above effect may
be achieved by [A-C].
.LP
Insertion text must be stated in parentheses. One cannot expect the
program to figure out which of the characters in brackets is meant to
be inserted. In addition many of the commands listed below allow for
the same text as was matched to be inserted (thus, say, allowing one
to match any of the letters A to E and insert whichever was seen) and
for specifying text to be inserted if a given pattern or patterns is
or are not seen.
.LP
In the description of commands below I shall maintain the convention
that match text indicated by [text] and insertion text by (text).
The following commands are recognized:
.IP {[text](text):[text](text):...:[text](text)*(text)}
This string is the most general command available. Any number of
entries seperated by colons may appear within the braces. The string
will match any of the match texts, and will replace it by the
insertion text next to it. Thus to match abc or ABC and replace the
first string (if seen) by def but the second by g one could use the
line:
.DS
0C>{(abc)(def):(ABC)(g)}
.DE
The * is an optional special character that is followed by insertion
text that should be inserted if none of the match texts were seen.
Note that the use of this ensures that input will be recognized even
if it does not match any of the inputs. Thus if we change the above
example to:
.DS
0C>{(abc)(def):(ABC)(g)}(hi)
.DE
where the form (hi) matches the input "hi" and does not alter it, we
obtain a processor which will recognise the input "abchi" and output
"defhi" but will produce an error message on the input "hi", whereas
with the command:
.DS
0C>{(abc)(def):(ABC)(g)*(ho)}(hi)
.DE
the output with "abchi" would be unchanged and "hi" would be matched
and would produce "hohi".
.IP
This construction is general enough that all of the remaining text
manipulation commands could be written using it. However in some cases
this would be extremely unwieldly. Thus the remaining commands can be
thought of as abreviations for long constructions of this nature. This
will be reflected by writing the long form out for each of them.
.IP [matchtext]                  
The text must be present in the input. It is not altered. The
expansion is best shown by two examples:
.DS
0>(hello)
.DE
changes to
.DS
0>{(hello)(hello)}
.DE
and
.DS
0>[hello]
.DE
changes to
.DS
0>{[h](h):[e](e):[l](l):[o](o)}
.DE
It can be seen why the abbreviation is useful in the second case.
.IP ?[matchtext]
The text is matched optionally, i.e. it may or may not be present in
input. The presence or absence is maintained in the output. Thus
.DS
0>?(hello)
.DE
is equivalent to 
.DS
0>{(hello)(hello)*()}
.DE
.IP d[matchtext]
The text must be matched. It is deleted from output.
.DS
0>d(hello)
.DE
is equivalent to
.DS
0>{(hello)()}
.DE
.IP <[matchtext]
The text is matched optionally. Whether or not it is present nothing
is placed on the output.
.DS
<[hello]
.DE
is the same as
.DS
0>{(h)():(e)():(l)():(o)()*()}
.DE
.IP >(inserttext)
The text is matched optionally. If it is not present it is inserted
into the output.
.DS
0>>(hello)
.DE
is equivalent to
.DS
0>{(hello)(hello)*(hello)}
.DE
.DS
0>>[hello]
.DE
is meaningless.
.IP r[text](text)
The match text must be matched. If it is it is replaced by the
insertion text.
.DS
0>r(hello)(goodbye)
.DE
is the same as
.DS
0>{(hello)(goodbye)}
.DE
.IP /[text](text)
The match text is optionally matched. The insertion text is placed on
the output whether or not the match text was seen.
.DS
0>/[hello](goodbye)
.DE
is the same as
.DS
0>{(h)(goodbye):(e)(goodbye):(l)(goodbye):(o)(goodbye)*(goodbye)}
.DE
.IP
It might be noted that all the operators for optional match commands
are non letter symbols, while all those for enforced matches are
letters.
.LP
.NH 4
Number Commands
.LP
Number matching is used for strings where the numeric value of strings
of digits in the input is significant. A number is specified by the
form:
.DS
#123,12
.DE
This is an instruction to find a number between 12 and 123. The second
(minimum) number is optional. If it is not specified egretc
automatically inserts a value of its own. At present that value is 0.
A number command matches any number with as many or fewer digits than
the first number specified. If it sees such a number it checks to see
if it is in the range specified. If so, the number is left filled with
0's until it has as many digits as the maximum of the range. If not a
number out of range error is generated. Thus the command:
.DS
0>#123,12
.DE
will match the numbers 123, 100, 30, 1 and 200. It will not match the
number 3000 though. The output on seeing the numbers above will be,
respectively, 123, 100, 030, number out of range and number out of
range.
.LP
.NH 4
Command Concatenation
.LP
As written above the commands have limited use; they must attempt to
treat the various parts of a single input line in the same way.
However a command line is in fact a concatenation of any number of the
above commands (subject to a maximum line length of 255 characters).
Thus an actual line might look something like:
.DS
0sc>(U)>(G)>(C)<(G)>( )#12921,1<[ -]?[A-E]
.DE
which would match any of the following input converting them all to
UGC 00001A:
.DS
u1a
ucg1A
Ugcg 1-a
UgCg1   a
.DE
.SH Error messages
.LP
It is possible to specify two types of error message which are printed
if the input does not match any of the expressions. The line on which
they are specified begins with the symbol <. If text appears between
this and the first > symbol on the line, the message following the
> is only printed when the input begins with one of the strings
appearing between < and >, seperated by ,'s. Thus the line 
.DS
<abc,de>This input begins with either "abc" or "de".
.DE
matches input like "abc is the beginning of the alphabet" and prints
the message "This input..." but only if it was not matched by a line
above. If there is nothing between the < and > the message is taken to
be a catch-all error, to be output whenever input fails to match any
expression. This rule must appear after all the conditional error
messages or they will be ignored. If there is no such rule in the
configuration file input that does not match any expression will just
be echoed as is.
.LP
The symbol % in the error message is special. When used it should
always be followed by a % or an s. %% just quotes a (single) %. %s
causes a copy of the current input to be inserted in place of it.
.SH Notes
.LP
This facility, enabled by the -n option on the command line or in the
micro database ( also at preesent the dafault ) is designed for the
NOTES 01 or NED 01 suffixes found in NED entries. It allows one to
define a "notes" regular expression in egret.top and append this to
all expressions in micro_db. Input expressions are matched exactly for
this part ( it is therefore advisable to allow ( ) as one of the
options in one's notes expression ) and it is copied verbatim to the
output. 
.SH COMPILATION OPTIONS
.LP
The following command line arguments are recognized by egretc:
.RS
.IP -c:
Add cc flags. The argumant is appended to the flags passed
to cc when it is invoked.
.IP -C:
Replace cc flags. The argument forms the flag string passed
to cc, replacing whatever the previous one was.
.IP -f:
Add flex flags. The argument is appended to the
string that is passed to flex when the intermediate file is compiled.
.IP -F:
Replace flex flags. The argument is passed to flex when it is
invoked in place of the previous string.
.IP -i:
compile in case insensitive mode. This is the default. The
resulting program will not distinguish between lower and upper
case letters, and will output in upper case.
.IP -I:
compile in case sensitive mode. The resulting program is
case sensitive and preserves the input case.
.IP -l:
complete the compilation. This tells the program to run flex and cc to
produce an executable. This is the default.
.IP -L:
do not run flex or cc. This causes egretc to just output the files
muscles, egret.rect.c and egret.rect.h and not continue compiling.
.IP -n: 
include notes. See the section on notes above. This is the default.
.IP -N:
do not include notes. See the section on notes above.
.IP -o:
Redirect output to named file. The file is created if
it does not exist and overwritten if it does. Outfile defaults
to "egret".
.IP -s:
collapse spaces. See the desription of line control letters above.
This is the default.
.IP -S:
do not collapse spaces. See above.
.RE
The options -c, -C, -f, -F and -o all take arguments. The argument
should appear immediately after the option letter seperated from it by
a space. The options may appear in any order, but must occur before
the  name of the input file. Many of the options can be overridden by
line specific instruction letters. See above.


